---
title: "Predicting distributional ranges of rocky intertidal species using a multi-dataset approach"
format: html
embed-resources: true
editor: visual
author: Simons D-L, Hipperson H, Webb TJ, Spencer M, Mieszkowska N
chunk_output_type: inline
toc: true
message: false
warning: false
---

## Introduction

This pipeline replicates all analyses in Simons *et al* (2025) "Predicting distributional ranges of rocky intertidal species using a multi data set approach".

Multiple resources have been used in this pipeline, including this [SDM guide](https://rspatial.org/sdm/index.html), Tom's Euro benthos habitat species guide.

## Set-up

### Load packages

```{r}
#| label: load-packages
#| echo: true
#| results: false

packages <- c("devtools",
              "qiime2R", #github download
              "microbiome", #github download
              "tidyverse",
              "vegan",
              "ggforce",
              "phyloseq",
              "cowplot",
              "geosphere",
              'lme4',
              "car",
              "sf",
              "pROC", #ROC and AUC for model validation 
              "ncdf4",
              "raster",
              "lubridate",
              "terra",
              "geodata",
              "predicts",
              "sdmpredictors",
              "tidyterra",
              "exactextractr",
              "arrow",
              "here",
              "emodnet.wfs", #github
              "EMODnetWCS", #github
              "biooracler") #github

new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

invisible(lapply(packages, library, character.only = TRUE))
```

### Functions

```{r}
#| label: get-nearest-coastline-function

get_nearest_coastline <- function(environment_stack, occurance_data, condition) {
  
  # convert to Spatraster
  env_terra <- rast(environment_stack)
  
  # Get CRS from raster
  raster_crs <- crs(env_terra, proj = TRUE)
  
  # Create original points as SpatVector
  points <- vect(occurance_data,
                 geom = c("lon", "lat"),
                 crs = raster_crs)
  
  # Extract environmental values at points
  presvals <- extract(env_terra, points)
  
  # Identify rows where all extracted values (except ID) are NA
  na_rows <- which(apply(presvals[, -1], 1, function(x) all(is.na(x))))
  
  # Create mask for coastline cells (where condition == 1)
  coastline_mask <- condition == 1
  
  # Extract points representing coastline cells
  coastline_points <- as.points(coastline_mask, values = FALSE)
  
  # Extract coordinates from original points
  coords <- crds(points)
  
  # For each NA point, find closest coastline point and replace coordinates
  for (i in na_rows) {
    this_point <- points[i]
    dists <- distance(this_point, coastline_points)
    nearest_idx <- which.min(dists)
    nearest_coords <- crds(coastline_points[nearest_idx])
    
    coords[i, ] <- nearest_coords
  }
  
  # Rebuild corrected SpatVector with updated coordinates
  corrected_points <- vect(data.frame(occurance_data, coords),
                           geom = c("x", "y"),
                           crs = crs(points))
  
  # Extract environmental variables at corrected points
  presvals_corrected <- extract(env_terra, corrected_points)
  
  return(presvals_corrected)
}
```

## Occurrence data

### Import eDNA and visual occurrences

Let's first read in our occurrences and metadata.

```{r}
#| label: import-data

# occurance data
occurance_data <- read.csv(file = "Data/Occurrence_data/my_dataset/combined_methods_long_data.csv", row.names = 1)

# get lat long from meta data
metadata <- read.csv(file = "Data/Metadata/metadata.csv", na.strings = c(""))
metadata <- metadata %>%
  subset(select = c(localityID, exposure, decimalLongitude, decimalLatitude)) %>% unique() %>% na.omit()

# add lat long to occurance
occurance_data <- left_join(occurance_data, metadata)

# filter to only species of interest
species_list <- c(
  "Semibalanus balanoides",
  "Phorcus lineatus",
  "Chthamalus montagui",
  "Perforatus perforatus",
  "Patella depressa",
  "Bifurcaria bifurcata",
  "Asterias rubens"
)

occurance_data_reduced <- occurance_data %>% filter(taxa %in% species_list)
str(occurance_data_reduced)
```

Split into species of interest for combined and individual methods.

```{r}
#| label: filter-species-of-interest

# Clean species names to use in object names (e.g., "Semibalanus balanoides" -> "semibalanus")
clean_name <- function(name) {
  tolower(gsub(" ", "_", name))
}

# Loop through each species and create the filtered data frames
for (species in species_list) {
  clean <- clean_name(species)
  
  assign(paste0(clean, "_obs_both_methods"),
         occurance_data_reduced %>%
           filter(taxa == species, pa == 1) %>%
           select(taxa, decimalLongitude, decimalLatitude) %>%
           rename(lat = decimalLatitude, lon = decimalLongitude, species = taxa))

  assign(paste0(clean, "_obs_eDNA"),
         occurance_data_reduced %>%
           filter(taxa == species, method == "eDNA", pa == 1) %>%
           select(taxa, decimalLongitude, decimalLatitude) %>%
           rename(lat = decimalLatitude, lon = decimalLongitude, species = taxa))

  assign(paste0(clean, "_obs_visual"),
         occurance_data_reduced %>%
           filter(taxa == species, method == "Visual", pa == 1) %>%
           select(taxa, decimalLongitude, decimalLatitude) %>%
           rename(lat = decimalLatitude, lon = decimalLongitude, species = taxa))
}

# Check the data to make sure it loaded correctly
head(semibalanus_balanoides_obs_eDNA)
```

```{r}
#| label: latlong-extent

# Determine geographic extent of our data
# find general latitudinal and longitudinal boundaries

max_lat <- ceiling(max(occurance_data_reduced$decimalLatitude))
min_lat <- floor(min(occurance_data_reduced$decimalLatitude))
max_lon <- ceiling(max(occurance_data_reduced$decimalLongitude))
min_lon <- floor(min(occurance_data_reduced$decimalLongitude))

# Store boundaries in a single extent object
geographic_extent <- ext(x = c(min_lon, max_lon, min_lat, max_lat))
uk_extent <- ext(-11, 2, 49.5, 61)  # Westernmost to easternmost, southernmost to northernmost

# plot features
wrld <- world(path=".")
```

### Import GBIF occurrences

We can also other occurrences from GBIF. These have been \# for now to save time and memory. They have been loaded directly in.

```{r}
#| label: download-from-GBIF-semibalanus

minYear = 2020

# Semibalanus

#semibalanus_GBIF_obs <- geodata::sp_occurrence("semibalanus", "balanoides", geo=TRUE, ext = uk_extent)
#dups <- duplicated(semibalanus_GBIF_obs[, c('lon', 'lat')])
#semibalanus_GBIF_obs_nodups <- semibalanus_GBIF_obs[!dups, ]
#semibalanus_GBIF_obs_nodups_recent <- subset(semibalanus_GBIF_obs_nodups, year >= minYear)
#dim(semibalanus_GBIF_obs_nodups_recent)

#write.csv(semibalanus_GBIF_obs_nodups_recent, file = paste("Data/Occurrence_data/GBIF/semibalanus_",minYear,".csv", sep = ""))

semibalanus_GBIF_clean <- read.csv("Data/Occurrence_data/GBIF/semibalanus_2020.csv")
  
# Phorcus

#phorcus_GBIF_obs <- geodata::sp_occurrence("phorcus", "lineatus", geo=TRUE, ext = uk_extent)
#dups <- duplicated(phorcus_GBIF_obs[, c('lon', 'lat')])
#phorcus_GBIF_obs_nodups <- phorcus_GBIF_obs[!dups, ]
##phorcus_GBIF_obs_nodups_recent <- subset(phorcus_GBIF_obs_nodups, year >= minYear)

#write.csv(phorcus_GBIF_obs_nodups_recent, file = paste("Data/Occurrence_data/GBIF/phorcus_",minYear,".csv", sep = ""))

phorcus_GBIF_clean <- read.csv("Data/Occurrence_data/GBIF/phorcus_2020.csv")

# Chthamalus

#chthamalus_GBIF_obs <- geodata::sp_occurrence("chthamalus", "montagui", geo=TRUE, ext = uk_extent)
#dups <- duplicated(chthamalus_GBIF_obs[, c('lon', 'lat')])
#chthamalus_GBIF_obs_nodups <- chthamalus_GBIF_obs[!dups, ]
#chthamalus_GBIF_obs_nodups_recent <- subset(chthamalus_GBIF_obs_nodups, year >= minYear)

#write.csv(chthamalus_GBIF_obs_nodups_recent, file = paste("Data/Occurrence_data/GBIF/chthamalus_",minYear,".csv", sep = ""))

chthamalus_GBIF_clean <- read.csv("Data/Occurrence_data/GBIF/chthamalus_2020.csv")

# Perforatus perforatus

#perforatus_GBIF_obs <- geodata::sp_occurrence("perforatus", "perforatus", geo=TRUE, ext = uk_extent)
#dups <- duplicated(perforatus_GBIF_obs[, c('lon', 'lat')])
#perforatus_GBIF_obs_nodups <- perforatus_GBIF_obs[!dups, ]
#perforatus_GBIF_obs_nodups_recent <- subset(perforatus_GBIF_obs_nodups, year >= minYear)

#write.csv(perforatus_GBIF_obs_nodups_recent, file = paste("Data/Occurrence_data/GBIF/perforatus_",minYear,".csv", sep = ""))

perforatus_GBIF_clean <- read.csv("Data/Occurrence_data/GBIF/perforatus_2020.csv")

# Patella depressa

#patella_GBIF_obs <- geodata::sp_occurrence("patella", "depressa", geo=TRUE, ext = uk_extent)
#dups <- duplicated(patella_GBIF_obs[, c('lon', 'lat')])
#patella_GBIF_obs_nodups <- patella_GBIF_obs[!dups, ]
#patella_GBIF_obs_nodups_recent <- subset(patella_GBIF_obs_nodups, year >= minYear)

##write.csv(patella_GBIF_obs_nodups_recent, file = paste("Data/Occurrence_data/GBIF/patella_",minYear,".csv", sep = ""))

patella_GBIF_clean <- read.csv("Data/Occurrence_data/GBIF/patella_2020.csv")

# Bifurcaria bifurcata

#bifurcaria_GBIF_obs <- geodata::sp_occurrence("Bifurcaria", "bifurcata", geo=TRUE, ext = uk_extent)
#dups <- duplicated(bifurcaria_GBIF_obs[, c('lon', 'lat')])
#bifurcaria_GBIF_obs_nodups <- bifurcaria_GBIF_obs[!dups, ]
#bifurcaria_GBIF_obs_nodups_recent <- subset(bifurcaria_GBIF_obs_nodups, year >= minYear)

#write.csv(bifurcaria_GBIF_obs_nodups_recent, file = paste("Data/Occurrence_data/GBIF/bifurcaria_",minYear,".csv", sep = ""))

bifurcaria_GBIF_clean <- read.csv("Data/Occurrence_data/GBIF/bifurcaria_2020.csv")
```

### Visualize occurrences

```{r}
#| label: plot-occurance-GBIF-data-semibalanus

# Set the file path and open the PNG device
png(filename = paste("Figures/semibalanus_occs_map_", minYear, ".png", sep = ""),
    width = 800, height = 600)

# Plot commands
plot(wrld, xlim = c(-11, 3), ylim = c(49, 61), col = "light yellow", border = "light gray")

# Add GBIF points
points(semibalanus_GBIF_clean$lon, 
       semibalanus_GBIF_clean$lat, 
       col = 'darkgrey', 
       pch = 20)

# Add your points
points(x = semibalanus_balanoides_obs_both_methods$lon, 
       y = semibalanus_balanoides_obs_both_methods$lat, 
       col = "red", 
       pch = 20, 
       cex = 0.75)

# Close the device
dev.off()
```

```{r}
#| label: plot-occurance-GBIF-data-phorcus

# Set the file path and open the PNG device
png(filename = paste("Figures/phorcus_occs_map_", minYear, ".png", sep = ""),
    width = 800, height = 600)

# Plot commands
plot(wrld, xlim = c(-11, 3), ylim = c(49, 61), col = "light yellow", border = "light gray")

# Add GBIF points
points(phorcus_GBIF_clean$lon, 
       phorcus_GBIF_clean$lat, 
       col = 'darkgrey', 
       pch = 20)

# Add your points
points(x = phorcus_lineatus_obs_both_methods$lon, 
       y = phorcus_lineatus_obs_both_methods$lat, 
       col = "red", 
       pch = 20, 
       cex = 0.75)

# Close the device
dev.off()
```

```{r}
#| label: plot-occurance-GBIF-data-chthamalus

# Set the file path and open the PNG device
png(filename = paste("Figures/chthamalus_occs_map_", minYear, ".png", sep = ""),
    width = 800, height = 600)

# Plot commands
plot(wrld, xlim = c(-11, 3), ylim = c(49, 61), col = "light yellow", border = "light gray")

# Add GBIF points
points(chthamalus_GBIF_clean$lon, 
       chthamalus_GBIF_clean$lat, 
       col = 'darkgrey', 
       pch = 20)

# Add your points
points(x = chthamalus_montagui_obs_both_methods$lon, 
       y = chthamalus_montagui_obs_both_methods$lat, 
       col = "red", 
       pch = 20, 
       cex = 0.75)

# Close the device
dev.off()
```

```{r}
#| label: plot-occurance-GBIF-data-perforatus

# Set the file path and open the PNG device
png(filename = paste("Figures/perforatus_occs_map_", minYear, ".png", sep = ""),
    width = 800, height = 600)

# Plot commands
plot(wrld, xlim = c(-11, 3), ylim = c(49, 61), col = "light yellow", border = "light gray")

# Add GBIF points
points(perforatus_GBIF_clean$lon, 
       perforatus_GBIF_clean$lat, 
       col = 'darkgrey', 
       pch = 20)

# add my points
points(x = perforatus_perforatus_obs_both_methods$lon, 
       y = perforatus_perforatus_obs_both_methods$lat, 
       col = "red", 
       pch = 20, 
       cex = 0.75)

# Close the device
dev.off()
```

```{r}
#| label: plot-occurance-GBIF-data-patella

# Set the file path and open the PNG device
png(filename = paste("Figures/patella_occs_map_", minYear, ".png", sep = ""),
    width = 800, height = 600)

# Plot commands
plot(wrld, xlim = c(-11, 3), ylim = c(49, 61), col = "light yellow", border = "light gray")

# Add GBIF points
points(patella_GBIF_clean$lon, 
       patella_GBIF_clean$lat, 
       col = 'darkgrey', 
       pch = 20)

# add my points
points(x = patella_depressa_obs_both_methods$lon, 
       y = patella_depressa_obs_both_methods$lat, 
       col = "red", 
       pch = 20, 
       cex = 0.75)

# Close the device
dev.off()
```

```{r}
#| label: plot-occurance-GBIF-data-Bifurcaria

# Set the file path and open the PNG device
png(filename = paste("Figures/bifurcaria_occs_map_", minYear, ".png", sep = ""),
    width = 800, height = 600)

# Plot commands
plot(wrld, xlim = c(-11, 3), ylim = c(49, 61), col = "light yellow", border = "light gray")

# Add GBIF points
points(bifurcaria_GBIF_clean$lon, 
       bifurcaria_GBIF_clean$lat, 
       col = 'darkgrey', 
       pch = 20)

# add my points
points(x = bifurcaria_bifurcata_obs_both_methods$lon, 
       y = bifurcaria_bifurcata_obs_both_methods$lat, 
       col = "red", 
       pch = 20, 
       cex = 0.75)

# Close the device
dev.off()
```

### Sampling bias

```{r}
#| label: sampling-bias-points

# make a SpatVector
semibalanus_spat <- vect(semibalanus_GBIF_clean, geom=c("lon", "lat"), crs="+proj=longlat +datum=WGS84")
class(semibalanus_spat)

# create a SpatRaster with the extent of acgeo
r <- rast(semibalanus_spat)

# set the resolution of the cells to (for example) 1 degree
res(r) <- 1

# extend (expand) the extent of the SpatRaster a little
r <- extend(r, ext(r)+1)

# sample:
set.seed(13)
acsel <- spatSample(semibalanus_spat, size=1, "random", strata=r)

# to illustrate the method and show the result
p <- as.polygons(r)
plot(p, border='gray')
points(semibalanus_GBIF_clean)
points(acsel, cex=1, col='red', pch='x') # selected points in red
```

## Absence and presence points (background points)

Let's sample background points within a radius of presence points (as seen in VanDerWal et al, 2009).

***Grey points*** are a random sample of 1000 points taken from within 30km around presence points. One point is sampled per raster cell to avoid spatial bias. These represent **candidate pseudo-absence locations** i.e. background points from within the accessible area.

***Blue points*** are a subset of the grey points. These are points whose raster cell center falls within the buffer circles. They represent **final valid** **pseudo-absences**.

```{r}
#| label: sample-psudo-absences

# circles with a radius of 30 km
x <- raster::buffer(semibalanus_spat, 30000)
pol <- aggregate(x)

# take a random sample of points within the polygons. 
# We only want one point per grid cell, sampling randomly from all circles
set.seed(999)
samp1 <- spatSample(pol, 1000, "random")

# no raster cells multiple times
pcells <- cells(r, samp1)
pcells <- unique(pcells[,2]) # remote duplicates
xy <- xyFromCell(r, pcells) # back to coordinates

# choose to select only those cells that have centers within circles
spxy <- vect(xy, crs="+proj=longlat +datum=WGS84")
xyInside <- intersect(spxy, x)

# plots to inspect results
plot(pol, axes=TRUE)
points(samp1, pch="+", cex=.5)
points(xyInside, cex=0.75, pch=20, col='blue')
```

## Environmental data

It's time to find environmental variables of interest. OCLE (<https://ocle.ihcantabria.com/>) provides meteo-oceanographic data for UK coastal communities, some of which are projected under future climate change scenarios.

To match the resolution of the projected estimates, we are going to download annual mean for each variable. Summer mean is available for historic periods, but not for projected periods.

```{r}
#| label: plot-features

# set uk extent and colours
uk_extent <- extent(-11, 2, 49.5, 61)
cols <- colorRampPalette(c("blue", "lightblue", "yellow", "red"))(100)
```

### Temp, pH, terrain (Bio-ORCLE)

Bio-ORACLE is a comprehensive data set providing a wide range of marine environmental variables tailored for ecological and biogeographical analysis. These variables include surface and benthic values for parameters such as temperature, salinity, nutrients, oxygen, pH, and more, derived from satellite and modeled oceanographic data.

We use the `biooracler` package here to obtain our environmental variables of interest from current and projected periods. We just load the datasets and skip running this code for now to save memory.

```{r}
#| label: variables-from-biooracle
#| eval: false
#| include: false

# explore layers
biooracler_layers <- biooracler::list_layers()

# example of selecting five variables from three datasets
datasets <- list(

  #air temps
  list(dataset_id = "tas_baseline_2000_2020_depthsurf",
       variables = "tas_mean",
       constraints = 
         list(#time = c('2000-01-01T00:00:00Z', '2010-01-01T00:00:00Z'), 
              latitude = c(49.5, 61), longitude = c(-11, 2))),
  
  list(dataset_id = "tas_ssp585_2020_2100_depthsurf",
       variables = "tas_mean",
       constraints = 
         list(#time = c('2020-01-01T00:00:00Z', '2090-01-01T00:00:00Z'), 
              latitude = c(49.5, 61), longitude = c(-11, 2))),
  
  #ocean temps
  list(dataset_id = "thetao_baseline_2000_2019_depthsurf",
       variables = "thetao_mean",
       constraints = list(
         #time = c('2000-01-01T00:00:00Z', '2010-01-01T00:00:00Z'), 
         latitude = c(49.5, 61), longitude = c(-11, 2))), 
  
  list(dataset_id = "thetao_ssp585_2020_2100_depthsurf",
       variables = "thetao_mean",
       constraints = list(
         #time = c('2000-01-01T00:00:00Z', '2010-01-01T00:00:00Z'), 
         latitude = c(49.5, 61), longitude = c(-11, 2))), 
  
  # pH
  list(dataset_id = "ph_baseline_2000_2018_depthsurf",
       variables = "ph_mean",
       constraints = list(
         #time = c('2000-01-01T00:00:00Z', '2010-01-01T00:00:00Z'), 
         latitude = c(49.5, 61), longitude = c(-11, 2))),
  
  list(dataset_id = "ph_ssp585_2020_2100_depthsurf",
       variables = "ph_mean",
       constraints = list(
         #time = c('2000-01-01T00:00:00Z', '2010-01-01T00:00:00Z'), 
         latitude = c(49.5, 61), longitude = c(-11, 2))),
  
  list(dataset_id = "terrain_characteristics",
       variables = "coastline",
       constraints = list(
         #time = c('2000-01-01T00:00:00Z', '2010-01-01T00:00:00Z'), 
         latitude = c(49.5, 61), longitude = c(-11, 2)))
  
  )

# download layers
for (dataset in datasets) {
  
  dataset_id <- dataset$dataset_id
  variables <- dataset$variables
  constraints <- dataset$constraints
  
  layer <- download_layers(dataset_id, variables = variables, constraints = constraints)
  
  # Save using dataset_id
  save_path <- file.path("Processed_Data/BIO-ORACLE", paste0(dataset_id, ".rds"))
  saveRDS(layer, save_path)
}
```

```{r}
#| label: read-and-explore-variables

## ocean temp
ocean_temp_present = readRDS("Data/Environmental_data/BIO-ORACLE/thetao_baseline_2000_2019_depthsurf.rds")
plot(
  ocean_temp_present,
  col = cols
)

ocean_temp_projected = readRDS("Data/Environmental_data/BIO-ORACLE/thetao_ssp585_2020_2100_depthsurf.rds")
plot(
  ocean_temp_projected,
  col = cols
)

## air temp
air_temp_present = readRDS("Data/Environmental_data/BIO-ORACLE/tas_baseline_2000_2020_depthsurf.rds")
plot(
  air_temp_present,
  col = cols
)

air_temp_projected = readRDS("Data/Environmental_data/BIO-ORACLE/tas_ssp585_2020_2100_depthsurf.rds")
plot(
  air_temp_projected,
  col = cols
)

## ph
ph_present = readRDS("Data/Environmental_data/BIO-ORACLE/ph_baseline_2000_2018_depthsurf.rds")
plot(ph_present,
     col = cols)

ph_projected = readRDS("Data/Environmental_data/BIO-ORACLE/ph_ssp585_2020_2100_depthsurf.rds")
plot(ph_projected,
     col = cols)

# terrain
terrain <- readRDS("Data/Environmental_data/BIO-ORACLE/terrain_characteristics.rds")
plot(terrain,
     main = "Terrain")
```

```{r}
#| label: create-stack

enviro_vars_current <- stack(
  c(ocean_temp_present,
    air_temp_present,
    ph_present,
    terrain
    ))

plot(enviro_vars_current) # plots each decade

enviro_vars_projected <- stack(
  c(ocean_temp_projected,
    air_temp_projected,
    ph_projected,
    terrain
    ))

plot(enviro_vars_projected) # plots each decade
```

### Rocky substrate (EMODnet)

We can use the package `emodnet.wfs` to obtain a full UK habitat map from EMODnet servers. Documentation for this service is [here](https://docs.ropensci.org/emodnet.wfs/).

```{r}
#| label: import-from-emodnet_wfs

# service information 
services <- emodnet_wfs()
services[, c("emodnet_thematic_lot", "service_name")]

# initialising a client is the first step to interacting with an EMODnet Web Feature Services
#wfs_geo <- emodnet_init_wfs_client(service = "geology_seabed_substrate_maps")
wfs_seabed <- emodnet_init_wfs_client(service =  "seabed_habitats_general_datasets_and_products")

# List contents of a WFS
layer_info <- emodnet.wfs::emodnet_get_wfs_info(wfs_seabed)
layer_info

# get descripion
layer_info %>%
  filter(layer_name == "ukseamap_latest_habitats") %>%
  pull(abstract) %>%
  cat()

# only UKASH Mosaic of Localised Maps includes intertidal zone

# define layer
layers <- c("ukseamap_latest_habitats") 

# get the data
emodnet_substrate <- emodnet_get_layers(wfs = wfs_seabed,
                                        layers = layers,
                                        simplify = TRUE)
# explore the data
emodnet_substrate
unique(colnames(emodnet_substrate))
unique(emodnet_substrate$eunis_name)
unique(emodnet_substrate$country)

# get hard rock only - no littoral :(
rock_hard_substrate <- emodnet_substrate %>%
  filter(str_detect(str_to_lower(eunis_name), "rock"))

#plot (takes horrendously long)
#ggplot(rock_hard_substrate) +
  #geom_sf(aes(fill = eunis_name)) +
  #scale_fill_viridis_d(option = "plasma", name = "Substrate Type") +
  #coord_sf(crs = 4326) +
  #theme_minimal() +
  #labs(
    #title = "EMODnet Habitat Map",
    #x = "Longitude", y = "Latitude"
  #)
```

Unfortunately, we couldn't get intertidal data from the above products. Let's try the JNCC UKASH Mosaic of Localized Maps which does include intertidal data, but only for 12% of the UK.

```{r}
#| label: read-in-UKASH-mosaic

# Path to the unzipped .gdb folder for UKASH Mosaic of Localised Maps (with intertidal zone)
gdb_path <- "Data/Environmental_data/JNCC/UKASH_MosaicOfLocalisedMaps_v2025.gdb"

# List available layers
st_layers(gdb_path)

# read in
ukash <- st_read(gdb_path, layer = "UKASH_MosaicLocalisedMaps_v2025_1")

# explore
print(ukash)

# filter for rocky only
rock_ukash <- ukash %>%
  filter(str_detect(str_to_lower(OrigName), "rock"))

# plot
rock_ukash_plot <- ggplot(rock_ukash) +
  geom_sf(aes(fill = OrigName)) +
  scale_fill_viridis_d(option = "plasma", name = "Substrate Type") +
  coord_sf(crs = 4326) +
  theme_minimal() +
  labs(
    title = "UKASH Mosaic Localised Rock Habitat Map",
    x = "Longitude", y = "Latitude"
  ) + theme(legend.position = "none")

ggsave(rock_ukash_plot, filename = "Figures/UKASH_Mosaic_Localised_Rock.jpeg")
```

### Visualize occurrence over variables

```{r}
#| label: view-obs-on-temp

# second layer of the SpatRaster (current ocean temp)

# we do not need the first column
semibalanus_balanoides_obs_both_methods  <- semibalanus_balanoides_obs_both_methods[,-1]

patella_depressa_obs_both_methods <- patella_depressa_obs_both_methods[,-1]

# semibalanus
plot(enviro_vars_current, 2, col = cols)
lines(wrld)
points(semibalanus_balanoides_obs_both_methods,
       col='blue')

# patella
plot(enviro_vars_current, 2, col = cols)
lines(wrld)
points(patella_depressa_obs_both_methods,
       col='blue')
```

### Extract value of predictors at occurrence points

We use the `extract` function from the `raster` package.

```{r}
#| label: extract-values

#extract
presvals_semibalanus <- extract(enviro_vars_current, semibalanus_balanoides_obs_both_methods) 

head(presvals_semibalanus)
```

We can see that some points are being treated as land rather than sea (we've got quite a few NAs). We need to find the closest point which is classed as coastline and use that instead.

```{r}
#| label: correct-points

# call function we created eariler to correct points
presvals_semibalanus_corrected <- get_nearest_coastline(
  enviro_vars_current,
  semibalanus_balanoides_obs_both_methods,
  terrain)

# remove the ID variable
presvals_semibalanus_corrected <- presvals_semibalanus_corrected[,-1]

# check the new data
head(presvals_semibalanus_corrected)
```

```{r}

# setting random seed to always create the same
# random set of points for this example
set.seed(0)

enviro_vars_current_rast <- rast(enviro_vars_current)
backgr <- spatSample(enviro_vars_current_rast, 500, "random", as.points=TRUE, na.rm=TRUE)
absvals <- values(backgr)
pb <- c(rep(1, nrow(presvals_semibalanus_corrected)), rep(0, nrow(absvals)))
sdmdata <- data.frame(cbind(pb, rbind(presvals_semibalanus_corrected, absvals)))
head(sdmdata)
tail(sdmdata)
summary(sdmdata)
```

### Check co-linearity

```{r}
#| label: check-colinearity

pairs(sdmdata[,2:5], cex=0.1) #air temp and ocean temp highly correlate
pairs(sdmdata[,5:8], cex=0.1) #pH with temp looks fine
```

We can see that air temp and ocean temp are highly correlated, hence we only want to use one of these variables.

## Model fitting

```{r}

m1 <- glm(pb ~ thetao_mean_2 + ph_mean_2, data=sdmdata)
class(m1)

summary(m1)
```

## Model prediction

```{r}

bc <- envelope(presvals_semibalanus_corrected[,c("thetao_mean_2", "ph_mean_2")])
bc

```

## Model evaluation
